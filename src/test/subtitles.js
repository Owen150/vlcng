const subtitles = `Programming is a highly creative process. High creativity mean less likelihood of thinking alike. Therefore collaborative programming is almost always difficult to navigate.I have always found it difficult to collaborate with other programmers. In a team of 3 programmers, I write almost all, if not all, of the code. This led me to ask: why is that? After observing the patterns, I came up with a few rules that I will use next time I collaborate. Creating a team. Notice that in the university everyone is learning. Unlike the workplace, at least generally, people have zero to little real-world programming experience. It, therefore, follows that since everyone is learning, collaboration will be difficult. If programmers in the workplace encounter integration conflicts, undoubtedly in the university there are bound to be even more conflicts. In the same university, the programmers learning themselves have different aptitudes. Some learn faster than others. Others are more experienced than the others. More experienced programmers will naturally find it difficult to keep up with the rest. Furthermore, there can be a lack of a push to deliver. In the workplace, you don’t have a choice, you either mess up and leave or stay and cooperate. In the university, it is not that bad, the curriculum itself accounts for that. Therefore these factors make it difficult to create a team and ensure cooperation. A temptation then is to group up with more or less equally experienced peers. A bad idea because the aim of collaboration in the university is so much to help each other learn. Grouping up with equally experienced peers would translate to segregation based on aptitudes. The way out is to group up with industrious people. Yes, they may not be equally experienced or have a similar academic aptitude but, if they are industrious they can catch up and make up for a few blanks. If they are willing to learn then they will be able to follow along and do their part. Every team member should make sure they contribute to the project. Collaboration only happens when everyone writes code. You should acknowledge others people’s work and not override it just because you think it is not good enough. There is also a good chance your work is not good enough either. The team has to dedicate time to the project. Projects are not magically completed. Time has to be irrecoverably spent on the project. Otherwise, the project is worth nothing. Documentation. Programmers don’t like writing documentation. Lack of documentation breeds confusion and disorder. For this reason, documentation is needed for collaboration to happen. Documentation does not have to be some IEEE template that looks very intimidating. Don't even bother with online diagramming tools. You can even draw diagrams by hand and then take a photo with your phone. When you starting writing good and helpful documentation you will be naturally forced to use more sophisticated tools and standards. So take it slow, you probably don’t need such tools or standards. The point of documentation is not to show lots of work done. Sometimes we get carried away with drawing good diagrams and forget that these diagrams are just there to help us understand what is required. A lot of time can be wasted drafting documentation instead of ensuring everyone is understanding. A simple use-case diagram might just be enough. Without them you end up writing code you never use, wasting time on features that you will through away. Before starting to work on anything you should agree on the goals lest you risk wasting time. The other benefit is that good documentation helps to avoid bikeshedding in programming, where a lot of time is taken working on a tiny issue instead of paying the most attention to what is core. A good use-case diagram can help to give an idea of the scope of the project thereby helping the programmer not to waste time on non-core functionality. Trello. Effective collaboration also depends on a good work breakdown structure. Work needs to be divided into sizeable units assignable to programmers and then scheduled. Trello was a useful tool for our team. Trello is a web-based list-making application where teams can keep track of events. Trello helps a team to schedule these tasks, assign them to people and keep track of which task has been done. One can also add a checklist to each task. All this ensures smooth communication. Don’t depend on Whatsapp to communicate. There is a chance that important project assignments or updates may be buried by other Whatsapp chats. Trello’s user interface. As in the image above, you can create a list of tasks. You can also set their due date. When a task is not currently being done it resides under To Do. When someone starts working on a task they can move to Doing and finally when they are done with it they can move it to Done. With this, the project easy to track and coordinate. Online meetings. Once everyone is done doing their task, integration is needed to merge the work done into a full feature. The easiest way to do it is via a meeting especially if documentation was poorly done and also because the team is learning on the job. There is never enough time to work on the documentation to the quality that meeting-free code integration demands. Such meetings should not run long, about an hour should be enough. The aim should be to agree on how code should be written. All the code does not need to be written during the meeting. Longer meetings will reduce productivity. Meeting the deadlines. It is so easy to underestimate the time a feature will take to be completed. You can only depend on experience to make an estimate. Regardless, the project has to somehow fit in the schedule. You might have to make changes to the deadlines depending on your current situation. Always add a margin for error when setting deadlines. One hindrance to beating the deadlines is bikeshedding where, as we have seen before, a programmer focuses on tiny little details while forgetting the core stuff. Often working in such a way guarantees that the deadline won't be met. Your biggest priority should be to deliver the core features first then work on the bikeshed details if time allows. Closely related, another danger is using a lot of time early on in project. Taking too much time when starting the project often results in having very little time to handle the most significant module of the project. Prioritizing the most significant features means giving them the most time. Conclusion. Collaboration therefore needs careful selection of a development team, helpful documentation, use of tools like Trello, a good work breakdown structure and a realistic schedule.`;

const subtitleBox = document.getElementById("subtitleBox");
console.log("String length " + subtitles.length);
const lineLength = 70;
let start = 0;
let end = lineLength - 1;
let length = subtitles.length;
let iteration = 0;
while (length > 0) {
    const subtitleLine = subtitles.slice(start, end);
    start += lineLength;
    end += lineLength;
    length -= lineLength;
    setTimeout(() => {
        subtitleBox.innerHTML = subtitleLine;
        // console.log(subtitleLine);
    }, 1000 + iteration * 1000);
    iteration++;
}
